%{
    
    #include "Symtab.hpp"
    #include "utils.hpp"
    #include "hw3_output.hpp"
    #define YYSTYPE Node*
    extern int yylex();
    extern int yylineno;
    using namespace output;
    void yyerror(const char*); 
    
    

    

    parmStack parm_stack;
    int whileCounter = 0;
%}

%nonassoc LOW_PREC_PAREN_EXP

%token INT BYTE BOOL
%token TRUE FALSE
%token BREAK CONTINUE
%token RETURN
%token STRING
%token WHILE
%token IF

%nonassoc NUM
%nonassoc B

%nonassoc ID
%nonassoc SC

%right ASSIGN
%left OR
%left AND
%left EQUALORNOT 
%left RELOP 
%left MINUS_PLUS 
%left DIV_MUL 
%right NOT
%left LPAREN RPAREN
%left LBRACE RBRACE

%nonassoc ELSE

%nonassoc Max_Priority

%%

Program: Statements {
   ;};

Statements:
    Statement {;}
     | Statements Statement {;};

Statement:
    Type ID ASSIGN Exp SC {parm_stack.addNewSymbolWithExp($1->m_value, $2->m_value, dynamic_cast<Expression*>($4));}
    | IF LPAREN BoolExp RPAREN AddScope Statement CloseScope {;}
    | RETURN SC {;}
    | Type ID SC {parm_stack.addNewSymbolNoExp($1->m_value, $2->m_value);}
    | IF LPAREN BoolExp RPAREN AddScope Statement CloseScope ELSE AddScope Statement CloseScope {;}
    | LBRACE AddScope Statements RBRACE CloseScope {;}
    | WHILE LPAREN BoolExp RPAREN {whileCounter++;} AddScope {;} Statement {whileCounter--;} CloseScope {;}
    | ID ASSIGN Exp SC {parm_stack.assignToSymbol($1->m_value, dynamic_cast<Expression*>($3));}
    | Call SC %prec Max_Priority {;}

    | BREAK SC {isLegalToBreak(whileCounter);}
    | CONTINUE SC {isLegalToCont(whileCounter);}
;
AddScope:              {parm_stack.addScope();}

CloseScope:            {parm_stack.popAndPrintScope();}

BoolExp:        Exp {isBoolean(dynamic_cast<Expression*>($1)); $$ = $1;}

Call: ID LPAREN Exp RPAREN {$$ = expressionToCall($1->m_value, dynamic_cast<Expression*>($3));};

Type:
    INT {$$ = new Type("int");}
    | BYTE {$$ = new Type("byte");}
    | BOOL {$$ = new Type("bool");}
;

Exp:  LPAREN Exp RPAREN %prec LOW_PREC_PAREN_EXP {$$ = $2;}
     | Exp MINUS_PLUS Exp {$$ = addOrSub(dynamic_cast<Expression*>($1), dynamic_cast<Op*>($2), dynamic_cast<Expression*>($3));}
     | Exp DIV_MUL Exp {$$ = mulDiv(dynamic_cast<Expression*>($1), dynamic_cast<Op*>($2), dynamic_cast<Expression*>($3));}
     | ID {$$ = id_to_Exp($1->m_value);}
     | Call {$$ = call_to_Exp(dynamic_cast<Call*>($1));}
     | NUM {$$ = new Expression("int", $1->m_value);}
     | NUM B {isLegalByte($1->m_value); $$ = new Expression("byte", $1->m_value);}
     | STRING {$$ = new Expression("string", $1->m_value);}
     | TRUE {$$ = new Expression("bool", "true");}
     | FALSE {$$ = new Expression("bool", "false");}
     | NOT Exp {$$ = Not(dynamic_cast<Expression*>($2));}
     | Exp AND Exp {$$ = And(dynamic_cast<Expression*>($1), dynamic_cast<Expression*>($3));}
     | Exp OR Exp {$$ = Or(dynamic_cast<Expression*>($1), dynamic_cast<Expression*>($3));}
     | Exp EQUALORNOT Exp {$$ = EqualOperations(dynamic_cast<Expression*>($1), dynamic_cast<Op*>($2), dynamic_cast<Expression*>($3));}
     | Exp RELOP Exp {$$ = EqualOperations(dynamic_cast<Expression*>($1), dynamic_cast<Op*>($2), dynamic_cast<Expression*>($3));}
     | LPAREN Type RPAREN Exp {$$ = Casting(dynamic_cast<Type*>($2), dynamic_cast<Expression*>($4));}
;



%%

void yyerror(const char*) {output::errorSyn(yylineno); exit(1);}

int main() {
    int ret_val = yyparse();    
    parm_stack.popAndPrintScope();
    return ret_val;
}
